/* crosslink.js Copyright 2015-2018 Robert Monfera*/(function(a,b){'object'==typeof exports&&'undefined'!=typeof module?module.exports=b():'function'==typeof define&&define.amd?define(b):a.crosslink=b()})(this,function(){'use strict';function a(){return this.inputValues[0]}const b=[];let e=null,f=null;const g=void 0,h=(y)=>{for(let z;z=y.inputs.pop();){const B=z.ownUses.findIndex((C)=>C.c===z);z.ownUses.splice(B,1),z.ownUses.length||z.persist||h(z)}for(var A=0;A<y.ownUses.length;A++)h(A)},j=(y)=>{throw e=null,f=null,b.splice(0,b.length),new Error(y)},k=(y,z)=>{y===e&&j('Self-inserting nodes now unsupported.'),y.isSource||j('Values can only be put in source nodes.'),y===f&&console.warn(`Circularity detected: ${y.alias} <-- ${e.alias}`),z===g&&j(`Value ${z} isn't currently supported.`),f?b.push([y,z]):(f=y,y.inputValues[0]=z,y.invalidate(),y.propagate(),e=null,f=null,b.length&&k.apply(0,b.shift()))};let l={cellsMade:[],cellsMadeCount:0};const m=(y,z=[],A=a,B=!1)=>{if(32<z.length)throw new Error('Currently, up to 32 arguments are supported.');const C=new Uint32Array([0,0]),D=z.map((I,J)=>{const K=I.value;return C[K===g?1:0]|=1<<J,K}),E=[],F=()=>{for(let{invalidate:I}of E)I()},G=()=>{if(0===C[1]){e=H;var I=A.apply(H,D);H.value=I;for(let{propagate:J}of E)J()}},H={alias:y,isSource:!z.length,value:g,argFlags:C,inputValues:D,ownUses:E,calc:A,persist:B,inputs:z.slice(),propagate:G,invalidate:F};return z.forEach((I,J)=>{const K=1<<J;I.ownUses.push({c:H,i:J,invalidate:()=>{D[J]===g||(D[J]=g,C[0]=0,C[1]|=K,F())},propagate:()=>{D[J]=z[J].value,C[0]|=K,C[1]&=~K,G()}})}),A&&!C[1]&&(H.value=A.apply(H,H.inputValues)),l.cellsMadeCount++,H};let o={};const p=(y)=>y+(o[y]?' '+ ++o[y]:(o[y]=1,'')),q=(y)=>(...z)=>{const A=z.filter((B)=>B.ownUses);if(A.length){let B;const C=z.map((D)=>D.ownUses?D:(B=m('lift const'),k(B,D),B));return m(p(y.name||y.toString()),C,y)}return y.apply(0,z)};return Object.assign(q,{cell:m,lift:q,reduce:(y)=>q(function(...z){return y(this.value,...z)}),put:k,scan:(y,z,A)=>m('scanned '+(y.name||y.toString())+' '+A.alias,[A],function(B){return y(this.value===g?z:this.value,B)}),merge:(y,z)=>{const A=m(`merger of ${y.alias} and ${z.alias}`);return m('merge from left '+y.alias,[y],(B)=>k(A,B)),m('merge from right '+z.alias,[z],(B)=>k(A,B)),A},delay:(y,z)=>{let A=m('delayed with'+(y+'ms of')+z.alias);return m('delaying with'+(y+'ms of')+z.alias,[z],function(B){setTimeout(()=>{k(A,B)},y)}),A},retain:(y)=>{return y.ownUses&&(y.persist=!0),y},remove:h,invalid:g,stats:()=>({statistics:l,getState:()=>({queue:b,currentCalc:e,currentPut:f}),currentCalc:()=>e,currentPut:()=>f})}),q});
