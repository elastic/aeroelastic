(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.crosslink = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/* crosslink.js Copyright 2015-2016 Robert Monfera*/(function(a,b){'object'==typeof exports&&'undefined'!=typeof module?module.exports=b():'function'==typeof define&&define.amd?define(b):a.crosslink=b()})(this,function(){'use strict';function a(){return this.inputValues[0]}const b=[];let e=null,f=null;const g=void 0,h=(z)=>{for(var A=0;A<z.ownUses.length;A++)z.ownUses[A].invalidate()},j=(z)=>{for(let A;A=z.inputs.pop();){const C=A.ownUses.findIndex((D)=>D.c===A);A.ownUses.splice(C,1),A.ownUses.length||A.persist||j(A)}for(var B=0;B<z.ownUses.length;B++)j(B)},k=(z)=>{if(e=z,!(z.inputValues.indexOf(g)+1)){var A=z.calc.apply(z,z.inputValues);if(A!==g){z.value=A;for(var B=0;B<z.ownUses.length;B++)z.ownUses[B].propagate()}}},l=(z)=>{throw e=null,f=null,b.splice(0,b.length),new Error(z)},m=(z,A)=>{z===e&&l('Self-inserting nodes now unsupported.'),z.isSource||l('Values can only be put in source nodes.'),z===f&&console.warn(`Circularity detected: ${z.alias} <-- ${e.alias}`),A===g&&l(`Value ${A} isn't currently supported.`),f?b.push([z,A]):(f=z,z.inputValues[0]=A,h(z),k(z),e=null,f=null,b.length&&m.apply(0,b.shift()))};let n={cellsMade:[],cellsMadeCount:0};const o=(z,A=[],B=a,C=!1)=>{const D={alias:z,isSource:!A.length,value:g,inputValues:A.map((E)=>E.value),ownUses:[],calc:B,persist:C,inputs:A.slice()};for(let E=0;E<A.length;E++){const F=A[E];F.ownUses.push({c:D,invalidate:()=>{D.inputValues[E]!==g&&(D.inputValues[E]=g,h(D))},propagate:()=>{D.inputValues[E]=F.value,k(D)}})}return B&&-1===D.inputValues.indexOf(g)&&(D.value=B.apply(D,D.inputValues)),n.cellsMadeCount++,D};let q={};const r=(z)=>z+(q[z]?' '+ ++q[z]:(q[z]=1,'')),t=(z)=>(...A)=>{const B=A.filter((C)=>C.ownUses);if(B.length){let C;const D=A.map((E)=>E.ownUses?E:(C=o('lift const'),m(C,E),C));return o(r(z.name||z.toString()),D,z)}return z.apply(0,A)},w=(z,A)=>{const B=o(`merger of ${z.alias} and ${A.alias}`);return o('merge from left '+z.alias,[z],(C)=>m(B,C)),o('merge from right '+A.alias,[A],(C)=>m(B,C)),B};return Object.assign(t,{cell:o,lift:t,put:m,scan:(z,A,B)=>{const C=o('scan starter');return m(C,A),w(C,o('scanned '+(z.name||z.toString())+' '+B.alias,[B],function(D){return z(this.value===g?A:this.value,D)}))},merge:w,delay:(z,A)=>{let B=o('delayed with'+(z+'ms of')+A.alias);return o('delaying with'+(z+'ms of')+A.alias,[A],function(C){setTimeout(()=>{m(B,C)},z)}),B},retain:(z)=>{return z.ownUses&&(z.persist=!0),z},remove:j,invalid:g,stats:()=>({statistics:n,getState:()=>({queue:b,currentCalc:e,currentPut:f}),currentCalc:()=>e,currentPut:()=>f})}),t});

},{}]},{},[1])(1)
});